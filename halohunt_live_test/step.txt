Import the SDK to the index.js file.
import {ZegoExpressEngine} from 'zego-express-engine-webrtc'

Basic concepts:

ZEGO Express SDK: The real-time audio and video SDK developed by ZEGOCLOUD to help you quickly build high-quality, low-latency, and smooth real-time audio and video communications into your apps across different platforms, with support for massive concurrency.

Stream publishing: The process of the client app capturing and transmitting audio and video streams to the ZEGOCLOUD Real-Time Audio and Video Cloud.

Stream playing: The process of the client app receiving and playing audio and video streams from the ZEGOCLOUD Real-Time Audio and Video Cloud.

Room: The service for organizing groups of users, allowing users in the same room to send and receive real-time audio, video, and messages to each other.

Logging in to a room is required to perform stream publishing and playing.
Users can only receive notifications about changes in the room they are in (such as new users joining the room, existing users leaving the room, new audio and video streams being published, etc.).


Create a ZegoExpressEngine instance
To create a singleton instance of the ZegoExpressEngine class, pass in your AppID as the appID parameter and the Server URL as the server parameter. You can obtain them from the ZEGOCLOUD Admin Console.

// Initialize the ZegoExpressEngine instance
const zg = new ZegoExpressEngine(appID, server);


Check your browser's WebRTC support
Before starting to publish or play a stream, you can call the checkSystemRequirements method to check if your browser supports WebRTC.

For more information about the browser versions supported by the SDK, see Browser compatibility.

const result = await zg.checkSystemRequirements();
// The [result] indicates whether it is compatible. It indicates WebRTC is supported when the [webRTC] is [true]. For more results, see the API documents.
console.log(result);
// {
//   webRTC: true,
//   customCapture: true,
//   camera: true,
//   microphone: true,
//   videoCodec: { H264: true, H265: false, VP8: true, VP9: true },
//   screenSharing: true,
//   errInfo: {}
// }


To log in to a room, call the loginRoom with the following parameters:

A unique room ID as the roomID parameter
The login token you obtained in the previous step as the token parameter
The user ID and user name as the roomID and userName parameter
userID must be the same as the one used in token generation.
Optional: Pass the corresponding object to the config parameter based on the actual situation.
If the roomID does not exist, a new room will be created and you will log in automatically when you call the loginRoom method.
// Log in to a room. It returns `true` if the login is successful.
// The roomUserUpdate callback is disabled by default. To receive this callback, you must set the `userUpdate` property to `true` when logging in to a room. 
const result = await zg.loginRoom(roomID, token, {userID: userID, userName: userName}, {userUpdate: true});

// Callback for updates on the current user's room connection status.
zg.on('roomStateUpdate', (roomID,state,errorCode,extendedData) => {
    if (state == 'DISCONNECTED') {
        // Disconnected from the room
    }

    if (state == 'CONNECTING') {
        // Connecting to the room
    }

    if (state == 'CONNECTED') {
        // Connected to the room
    }
})

// Callback for updates on the status of ther users in the room.
zg.on('roomUserUpdate', (roomID, updateType, userList) => {
    console.warn(
        `roomUserUpdate: room ${roomID}, user ${updateType === 'ADD' ? 'added' : 'left'} `,
        JSON.stringify(userList),
    );
});

// Callback for updates on the status of the streams in the room.
zg.on('roomStreamUpdate', async (roomID, updateType, streamList, extendedData) => {
    if (updateType == 'ADD') {
        // New stream added, start playing the stream. 
    } else if (updateType == 'DELETE') {
        // Stream deleted, stop playing the stream.
    }
});


Publish streams
To create a local audio and video stream, call the createZegoStream method. By default, the engine captures video data from the camera and captures audio data from the microphone.

After calling the createZegoStream method, you need to wait for the ZEGO server to return the media stream object (localStream) before any further operation.

// After calling the createZegoStream method, you need to wait for the ZEGO server to return the local stream object before any further operation.
const localStream = await this.zg.createZegoStream();

// Play preview of the stream
localStream.playVideo(document.querySelector("#local-video"));

// localStream is the MediaStream object created by calling creatStream in the previous step.
zg.startPublishingStream(streamID, localStream)

Then, to listen for and handle various events that may happen after stream publishing starts, you can implement the corresponding event callback methods of the event handler as needed. The following are some common event callbacks related to stream publishing:

publisherStateUpdate: Callback for updates on stream publishing status. After stream publishing starts, if the status changes, (for example, when the stream publishing is interrupted due to network issues and the SDK retries to start publishing the stream again), the SDK sends out the event notification through this callback.

publishQualityUpdate: Callback for reporting stream publishing quality. After stream publishing starts, the SDK sends out the streaming quality data (resolution, frame rate, bit rate, etc.) regularly through this callback.

zg.on('publisherStateUpdate', result => {
    // Callback for updates on stream publishing status.
    // ... 
})

zg.on('publishQualityUpdate', (streamID, stats) => {
    // Callback for reporting stream publishing quality.
    // ... 
})

Play streams
To start playing a remote audio and video stream from the ZEGO server, call the startPlayingStream method with the corresponding stream ID passed to the streamID parameter.

You can obtain the stream ID of the streams published by remote users from the callback roomStreamUpdate.

It is recommended to use createRemoteStreamView to play media streams, and it is not advisable to use audio or video tags to play media streams.

const remoteStream = await zg.startPlayingStream(streamID);

const remoteView= zg.createRemoteStreamView(remoteStream);
// The remote-video is the <div> element's id on your webpage.
remoteView.play("remote-video", {enableAutoplayDialog:true});

zg.on('playerStateUpdate', result => {
    // Callback for updates on stream playing status.
    // ...
})

zg.on('playQualityUpdate', (streamID,stats) => {
    // Callback for reporting stream playing quality.
})


Stop publishing and playing streams
To stop publishing a local audio and video stream to remote users, call the stopPublishingStream method with the corresponding stream ID passed to the streamID parameter.

zg.stopPublishingStream(streamID)
Then, to destroy a local media stream, call the destroyStream method. After destroying the local media stream, you need to manually destroy the video element.

// localStream is the MediaStream object created when calling the createZegoStream method.
zg.destroyStream(localStream)
Then, to stop playing a remote audio and video stream, call the stopPlayingStream method with the corresponding stream ID passed to the streamID parameter.

zg.stopPlayingStream(streamID)

zg.logoutRoom(roomID)